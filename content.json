{"meta":{"title":"huangxingx","subtitle":"Follow Your Heart.","description":null,"author":"huangxingx","url":"https://huangxingx.github.io","root":"/"},"pages":[],"posts":[{"title":"go-micro 使用注意事项","slug":"go-micro-precautions","date":"2019-11-05T10:30:57.000Z","updated":"2019-11-06T04:36:37.477Z","comments":true,"path":"2019/11/05/go-micro-precautions/","link":"","permalink":"https://huangxingx.github.io/2019/11/05/go-micro-precautions/","excerpt":"","text":"1. micro@v1.14 之后使用 consul 作为注册中心问题micro@v1.14 之后更换了默认的注册中心，把 consul 换成了 etcd ，如果需要使用 consul 作为注册中心，需要重新编译 micro。 clone 源码： git clone https://github.com/micro/micro.git 切到源码目录并新增 plugins.go : cd micro源码目录 vi plugins.go package main import ( _ &quot;github.com/micro/go-plugins/registry/consul&quot; ) 编译 go build -o mainWithConsul main.go plugins.go 运行 ./mainWithConsul --registry=consul api 具体文档请查看 micro@v1.14之后用户 consul作为注册中心解决方案 2. micro 用 Gin 作为 api 问题用 gin 做为 gin-api 服务时， 通过 micro new –type web 创建一个服务出来，注意修改服务的 name，改为 com.example.api.ServiceName,且在 gin router 中创建： router := gin.Default() r := router.Group(&quot;/ServiceName&quot;) 启动 micro api --namespace=com.example.api 这里必须要加 api 不然转发不了。 3. 使用 micro new 生成模板使用 micro new 生成模板， RegisterSubscriber 的 topic 名称和 service name 一样，导致大概50%的概率出现请求失败问题。 解决方法: 注释 RegisterSubscriber 部分代码，或者换一个 topic 名称。","categories":[{"name":"go","slug":"go","permalink":"https://huangxingx.github.io/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://huangxingx.github.io/tags/go/"},{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://huangxingx.github.io/tags/go-micro/"},{"name":"注意事项","slug":"注意事项","permalink":"https://huangxingx.github.io/tags/注意事项/"}]},{"title":"go-生成随机验证码","slug":"go-生成随机验证码","date":"2019-06-25T03:50:35.000Z","updated":"2019-06-25T03:51:52.612Z","comments":true,"path":"2019/06/25/go-生成随机验证码/","link":"","permalink":"https://huangxingx.github.io/2019/06/25/go-生成随机验证码/","excerpt":"","text":"package main import ( &quot;fmt&quot; &quot;math/rand&quot; &quot;strings&quot; &quot;time&quot; ) func GenValidateCode(width int) string { numeric := [10]byte{0,1,2,3,4,5,6,7,8,9} r := len(numeric) rand.Seed(time.Now().UnixNano()) var sb strings.Builder for i := 0; i &lt; width; i++ { fmt.Fprintf(&amp;sb, &quot;%d&quot;, numeric[ rand.Intn(r) ]) } return sb.String() } func main() { fmt.Println( GenValidateCode(6) ) }","categories":[{"name":"go","slug":"go","permalink":"https://huangxingx.github.io/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://huangxingx.github.io/tags/go/"}]},{"title":"go-生成随机字符串","slug":"go-生成随机字符串","date":"2019-06-13T07:41:22.000Z","updated":"2019-06-13T07:42:42.686Z","comments":true,"path":"2019/06/13/go-生成随机字符串/","link":"","permalink":"https://huangxingx.github.io/2019/06/13/go-生成随机字符串/","excerpt":"","text":"随机字符串 //RandomStr 随机生成字符串 func RandomStr(length int) string { str := &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; bytes := []byte(str) result := []byte{} r := rand.New(rand.NewSource(time.Now().UnixNano())) for i := 0; i &lt; length; i++ { result = append(result, bytes[r.Intn(len(bytes))]) } return string(result) } 生成定长字符串//获得定长字符串 //str 填充字符串 //length 获得定长的长度 //char 不够长时填充的字符 func GetFixedLenString(str string, length int, char byte) string { if len(str) == 0 { return &quot;&quot; } if len(str) == length { return str } //超出切后面 if len(str) &gt; length { return string(str[:length]) } //缺少添加char if len(str) &lt; length { slice := make([]byte, length-len(str)) for k := range slice { slice[k] = char } return string(append(slice, []byte(str)...)) } return &quot;&quot; } 获得定长byte slice//获得定长byte slice //str 填充字符串 //length 获得定长的长度 //char 不够长时填充的字符 func GetFixedLenByte(b []byte, length int, char byte) (tb []byte) { if len(b) == 0 { return } if len(b) == length { return b } //超出切后面 if len(b) &gt; length { return b[:length] } //缺少添加char if len(b) &lt; length { slice := make([]byte, length-len(b)) for k := range slice { slice[k] = char } return append(slice, []byte(b)...) } return }","categories":[{"name":"go","slug":"go","permalink":"https://huangxingx.github.io/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://huangxingx.github.io/tags/go/"}]},{"title":"mysql距离函数st_distance","slug":"mysql距离函数st-distance","date":"2019-06-12T07:58:59.000Z","updated":"2019-06-12T08:00:34.908Z","comments":true,"path":"2019/06/12/mysql距离函数st-distance/","link":"","permalink":"https://huangxingx.github.io/2019/06/12/mysql距离函数st-distance/","excerpt":"","text":"随着近几年各类移动终端的迅速普及，在手机移动定位app中，附近的人，附近的地点功能十分常见,基于地理位置的服务（LBS）和相关应用也越来越多，而支撑这些应用的最基础技术之一，就是基于地理位置信息的处理。 st_distance 函数st_distance 函数是从mysql5.6.1才加入的。SET @g1 = POINT(1,1), @g2 = POINT(2,2);select st_distance (@g1, @g2);输出结果：1.4142135623730951 SELECT st_distance (point (1, 1),point(2,2) ) * 111195 //输出结果：157253.47706807632 单位：米st_distance 计算的结果单位是度，需要乘111195（地球半径6371000*PI/180）是将值转化为米。 当然你也可以自定义距离函数： CREATE FUNCTION slc ( lat1 DOUBLE, lon1 DOUBLE, lat2 DOUBLE, lon2 DOUBLE ) RETURNS DOUBLE RETURN 6371 * acos( cos(radians(lat1)) * cos(radians(lat2)) * cos( radians(lon2) - radians(lon1) ) + sin(radians(lat1)) * sin(radians(lat2)) ); SELECT slc(1,1,2,2) from DUAL //输出结果：157.22543203804852 km 应用场景:假设我当时的坐标：117.069,35.86 需要查询我附近50KM内服务区，并按照距离由近及远排列 SELECT s.id,s.name,s.lng,s.lat, (st_distance (point (lng, lat),point(117.069,35.86) ) *111195) AS distance FROM road_servicearea s HAVING distance&lt;50 ORDER BY distance 知识科普：地球是在不停地绕地轴旋转，在地球中腰画一个与地轴垂直的大圆圈，使圈上的每一点都和南北两极的距离相等，这个圆圈就叫作“赤道”。在赤道的南北两边，画出许多和赤道平行的圆圈，就是“纬圈”；构成这些圆圈的线段，叫做纬线。我们把赤道定为纬度零度，向南向北各为90度，在赤道以南的叫南纬，在赤道以北的叫北纬。北极就是北纬90度，南极就是南纬90度。纬度的高低也标志着气候的冷热，如赤道和低纬度地地区无冬，两极和高纬度地区无夏，中纬度地区四季分明。 从北极点到南极点，可以画出许多南北方向的与地球赤道垂直的大圆圈，这叫作“经圈”；构成这些圆圈的线段，就叫经线。公元1884平面坐标图年，国际上规定以通过英国伦敦近郊的格林尼治天文台的经线作为计算经度的起点，即经度零度零分零秒，也称“本初子午线”。在它东面的为东经，共180度； 在它西面的为西经，共180度。因为地球是圆的，所以东经180度和西经180度的经线是同一条经线。各国公定180度经线为“国际日期变更线”。为了避免同一地区使用两个不同的日期，国际日期变线在遇陆地时略有偏离。每一经度和纬度还可以再细分为60分，每一分再分为60秒以及秒的小数。利用经纬线，我们就可以确定地球上每一个地方的具体位置，并且把它在地图或地球仪上表示出来。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://huangxingx.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://huangxingx.github.io/tags/mysql/"}]},{"title":"gorm-mysql-json","slug":"gorm-mysql-json","date":"2019-06-11T08:55:56.000Z","updated":"2019-06-11T08:59:27.114Z","comments":true,"path":"2019/06/11/gorm-mysql-json/","link":"","permalink":"https://huangxingx.github.io/2019/06/11/gorm-mysql-json/","excerpt":"","text":"Add new type named JSON and rewrite methods: package models import ( &quot;bytes&quot; &quot;errors&quot; &quot;database/sql/driver&quot; ) type JSON []byte func (j JSON) Value() (driver.Value, error) { if j.IsNull() { return nil, nil } return string(j), nil } func (j *JSON) Scan(value interface{}) error { if value == nil { *j = nil return nil } s, ok := value.([]byte) if !ok { errors.New(&quot;Invalid Scan Source&quot;) } *j = append((*j)[0:0], s...) return nil } func (m JSON) MarshalJSON() ([]byte, error) { if m == nil { return []byte(&quot;null&quot;), nil } return m, nil } func (m *JSON) UnmarshalJSON(data []byte) error { if m == nil { return errors.New(&quot;null point exception&quot;) } *m = append((*m)[0:0], data...) return nil } func (j JSON) IsNull() bool { return len(j) == 0 || string(j) == &quot;null&quot; } func (j JSON) Equals(j1 JSON) bool { return bytes.Equal([]byte(j), []byte(j1)) } Use new JSON type: package models type Model struct { ID int `gorm:&quot;primary_key&quot; json:&quot;id&quot;` CreatedAt int64 `json:&quot;createdAt&quot;` UpdatedAt int64 `json:&quot;updatedAt&quot;` Object JSON `sql:&quot;type:json&quot; json:&quot;object,omitempty&quot;` }","categories":[{"name":"go","slug":"go","permalink":"https://huangxingx.github.io/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://huangxingx.github.io/tags/go/"}]},{"title":"go-future","slug":"go-future","date":"2019-06-06T07:16:40.000Z","updated":"2019-06-06T07:24:40.831Z","comments":true,"path":"2019/06/06/go-future/","link":"","permalink":"https://huangxingx.github.io/2019/06/06/go-future/","excerpt":"","text":"golang Future 实现package utils import ( &quot;sync&quot; &quot;time&quot; ) /* Future 是一个未来的任务的抽象。和python里的那个有点类似。 在异步任务中SetResult，在GetResult的时候会等待result生成，或者超时。 使用姿势： tasks := make([]*utils.Future, 0) for i := 0; i &lt; 10; i++ { future := utils.NewFuture() tasks = append(tasks, future) go func(result int) { time.Sleep(time.Second * time.Duration(rand.Int63n(10))) future.SetResult(result) }(i) } for _, item := range tasks { ret, ok := item.GetResult().(int) if ok { fmt.Println(ret) } else { fmt.Println(&quot;failed&quot;) } } */ type Future struct { isfinished bool result interface{} resultchan chan interface{} l sync.Mutex } func (f *Future) GetResult() interface{} { f.l.Lock() defer f.l.Unlock() if f.isfinished { return f.result } select { // timeout case &lt;-time.Tick(time.Second * 6): f.isfinished = true f.result = nil return nil case f.result = &lt;-f.resultchan: f.isfinished = true return f.result } } func (f *Future) SetResult(result interface{}) { if f.isfinished == true { return } f.resultchan &lt;- result close(f.resultchan) } func NewFuture() *Future { return &amp;Future{ isfinished: false, result: nil, resultchan: make(chan interface{}, 1), } }","categories":[{"name":"go","slug":"go","permalink":"https://huangxingx.github.io/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://huangxingx.github.io/tags/go/"}]},{"title":"markdown","slug":"markdown","date":"2019-06-05T03:13:18.000Z","updated":"2019-06-05T04:38:33.760Z","comments":true,"path":"2019/06/05/markdown/","link":"","permalink":"https://huangxingx.github.io/2019/06/05/markdown/","excerpt":"","text":"#一、标题写法： 第一种方法： 1、在文本下面加上 等于号 = ，那么上方的文本就变成了大标题。等于号的个数无限制，但一定要大于0个哦。。 2、在文本下面加上 下划线 - ，那么上方的文本就变成了中标题，同样的 下划线个数无限制。 3、要想输入=号，上面有文本而不让其转化为大标题，则需要在两者之间加一个空行。 另一种方法：（推荐这种方法；注意⚠️中间需要有一个空格） 关于标题还有等级表示法，分为六个等级，显示的文本大小依次减小。不同等级之间是以井号 # 的个数来标识的。一级标题有一个 #，二级标题有两个# ，以此类推。 例如： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 二、编辑基本语法 1、字体格式强调 我们可以使用下面的方式给我们的文本添加强调的效果 *强调* (示例：斜体) _强调_ (示例：斜体) **加重强调** (示例：粗体) __加重强调__ (示例：粗体) ***特别强调*** (示例：粗斜体) ___特别强调___ (示例：粗斜体) 2、代码 `&lt;hello world&gt;` 3、代码块高亮 (```) @Override protected void onDestroy() { EventBus.getDefault().unregister(this); super.onDestroy(); } (```) 4、表格 （建议在表格前空一行，否则可能影响表格无法显示） 表头 | 表头 | 表头 ---- | ----- | ------ 单元格内容 | 单元格内容 | 单元格内容 单元格内容 | 单元格内容 | 单元格内容 5、其他引用 图片 ![图片名称](https://www.baidu.com/img/bd_logo1.png) 链接 [链接名称](https://www.baidu.com/) 6、列表 1. 项目1 2. 项目2 3. 项目3 * 项目1 （一个*号会显示为一个黑点，注意⚠️有空格，否则直接显示为*项目1） * 项目2 7、换行（建议直接在前一行后面补两个空格） 直接回车不能换行， 可以在上一行文本后面补两个空格， 这样下一行的文本就换行了。 或者就是在两行文本直接加一个空行。 也能实现换行效果，不过这个行间距有点大。 8、引用 &gt; 第一行引用文字 &gt; 第二行引用文字","categories":[{"name":"docs","slug":"docs","permalink":"https://huangxingx.github.io/categories/docs/"}],"tags":[{"name":"docs","slug":"docs","permalink":"https://huangxingx.github.io/tags/docs/"},{"name":"markdown","slug":"markdown","permalink":"https://huangxingx.github.io/tags/markdown/"}]},{"title":"doc-href","slug":"doc-href","date":"2019-06-04T08:20:14.000Z","updated":"2019-06-05T06:42:55.789Z","comments":true,"path":"2019/06/04/doc-href/","link":"","permalink":"https://huangxingx.github.io/2019/06/04/doc-href/","excerpt":"","text":"工具 hexo 文档 框架 Java dubbo Golang gorm 收藏网站 free-ss","categories":[{"name":"docs","slug":"docs","permalink":"https://huangxingx.github.io/categories/docs/"}],"tags":[{"name":"docs","slug":"docs","permalink":"https://huangxingx.github.io/tags/docs/"}]},{"title":"AMQP介绍","slug":"amqp-instraction","date":"2018-07-16T09:21:05.000Z","updated":"2019-06-05T04:42:16.392Z","comments":true,"path":"2018/07/16/amqp-instraction/","link":"","permalink":"https://huangxingx.github.io/2018/07/16/amqp-instraction/","excerpt":"AMQP介绍AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。 AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。 AMQP在消息提供者和客户端的行为进行了强制规定，使得不同卖商之间真正实现了互操作能力。 JMS是早期消息中间件进行标准化的一个尝试，它仅仅是在API级进行了规范，离创建互操作能力还差很远。 与JMS不同，AMQP是一个Wire级的协议，它描述了在网络上传输的数据的格式，以字节为流。因此任何遵守此数据格式的工具，其创建和解释消息，都能与其他兼容工具进行互操作。","text":"AMQP介绍AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。 AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。 AMQP在消息提供者和客户端的行为进行了强制规定，使得不同卖商之间真正实现了互操作能力。 JMS是早期消息中间件进行标准化的一个尝试，它仅仅是在API级进行了规范，离创建互操作能力还差很远。 与JMS不同，AMQP是一个Wire级的协议，它描述了在网络上传输的数据的格式，以字节为流。因此任何遵守此数据格式的工具，其创建和解释消息，都能与其他兼容工具进行互操作。 AMQP规范的版本：0-8 是2006年6月发布0-9 于2006年12月发布0-9-1 于2008年11月发布0-10 于2009年下半年发布1.0 draft （文档还是草案） AMQP的实现有： 1）OpenAMQAMQP的开源实现，用C语言编写，运行于Linux、AIX、Solaris、Windows、OpenVMS。 2）Apache QpidApache的开源项目，支持C++、Ruby、Java、JMS、Python和.NET。 3）Redhat Enterprise MRG实现了AMQP的最新版本0-10，提供了丰富的特征集，比如完全管理、联合、Active-Active集群，有Web控制台，还有许多企业级特征，客户端支持C++、Ruby、Java、JMS、Python和.NET。 4）RabbitMQ一个独立的开源实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、 ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ发布在Ubuntu、FreeBSD平台。 5）AMQP InfrastructureLinux下，包括Broker、管理工具、Agent和客户端。 6）?MQ一个高性能的消息平台，在分布式消息网络可作为兼容AMQP的Broker节点，绑定了多种语言，包括Python、C、C++、Lisp、Ruby等。 7）Zyre是一个Broker，实现了RestMS协议和AMQP协议，提供了RESTful HTTP访问网络AMQP的能力。 RabbitMQ 是一个由 Erlang 写成的 Advanced Message Queuing Protocol (AMQP) 实现，AMQP 的出现其实也是应了广大人民群众的需求，虽然在同步消息通讯的世界里有很多公开标准（如 COBAR 的 IIOP ，或者是 SOAP等），但是在异步消息处理中却不是这样，只有大企业有一些商业实现（如微软的 MSMQ ，IBM 的 Websphere MQ 等），因此，在 2006 年的 6 月，Cisco 、Redhat、iMatix 等联合制定了 AMQP 的公开标准。","categories":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://huangxingx.github.io/categories/rabbitmq/"}],"tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://huangxingx.github.io/tags/rabbitmq/"}]},{"title":"HTTP Status Code","slug":"http-status-code","date":"2018-04-18T09:21:05.000Z","updated":"2018-04-18T09:21:05.000Z","comments":true,"path":"2018/04/18/http-status-code/","link":"","permalink":"https://huangxingx.github.io/2018/04/18/http-status-code/","excerpt":"当用户试图通过HTTP或FTP协议访问一台运行主机上的内容时，Web服务器返回一个表示该请求的状态的数字代码。该状态代码记录在服务器日志中，同时也可能在 Web 浏览器或 FTP客户端显示。也就是我们打开页面发生错误时浏览器显示的错误信息代码。状态代码可以指明具体请求是否已成功，还可以揭示请求失败的确切原因。HTTP协议状态码表示的意思主要分为五类 ,大体是 : 1×× 保留 2×× 表示请求成功地接收 3×× 为完成请求客户需进一步细化请求 4×× 客户错误 5×× 服务器错误","text":"当用户试图通过HTTP或FTP协议访问一台运行主机上的内容时，Web服务器返回一个表示该请求的状态的数字代码。该状态代码记录在服务器日志中，同时也可能在 Web 浏览器或 FTP客户端显示。也就是我们打开页面发生错误时浏览器显示的错误信息代码。状态代码可以指明具体请求是否已成功，还可以揭示请求失败的确切原因。HTTP协议状态码表示的意思主要分为五类 ,大体是 : 1×× 保留 2×× 表示请求成功地接收 3×× 为完成请求客户需进一步细化请求 4×× 客户错误 5×× 服务器错误 100 Continue指示客户端应该继续请求。回送用于通知客户端此次请求已经收到，并且没有被服务器拒绝。客户端应该继续发送剩下的请求数据或者请求已经完成，或者忽略回送数据。服务器必须发送最后的回送在请求之后。 101 Switching Protocols服务器依照客服端请求，通过Upgrade头信息，改变当前连接的应用协议。服务器将根据Upgrade头立刻改变协议在101回送以空行结束的时候。 Successful200 OK指示客服端的请求已经成功收到，解析，接受。 201 Created请求已经完成并一个新的返回资源被创建。被创建的资源可能是一个URI资源，通常URI资源在Location头指定。回送应该包含一个实体数据并且包含资源特性以及location通过用户或者用户代理来选择合适的方法。实体数据格式通过煤体类型来指定即content-type头。最开始服务 器必须创建指定的资源在返回201状态码之前。如果行为没有被立刻执行，服务器应该返回202。 202 Accepted请求已经被接受用来处理。但是处理并没有完成。请求可能或者根本没有遵照执行，因为处理实际执行过程中可能被拒绝。 203 Non-Authoritative Information不是权威性信息。 204 No Content服务器已经接受请求并且没必要返回实体数据，可能需要返回更新信息。回送可能包含新的或更新信息由entity-headers呈现。 205 Reset Content服务器已经接受请求并且用户代理应该重新设置文档视图。 206 Partial Content服务器已经接受请求GET请求资源的部分。请求必须包含一个Range头信息以指示获取范围可能必须包含If-Range头信息以成立请求条件。 Redirection300 Multiple Choices请求资源符合任何一个呈现方式。 301 Moved Permanently请求的资源已经被赋予一个新的URI。 302 Found通过不同的URI请求资源的临时文件。 303 See Other304 Not Modified如果客服端已经完成一个有条件的请求并且请求是允许的，但是这个文档并没有改变，服务器应该返回304状态码。304状态码一定不能包含信息主体，从而通常通过一个头字段后的第一个空行结束。 305 Use Proxy请求的资源必须通过代理（由Location字段指定）来访问。Location资源给出了代理的URI。 306 Unused307 Temporary Redirect临时重定向。 Client Error400 Bad Request因为错误的语法导致服务器无法理解请求信息。 401 Unauthorized如果请求需要用户验证。回送应该包含一个WWW-Authenticate头字段用来指明请求资源的权限。 402 Payment Required保留状态码。 403 Forbidden服务器接受请求，但是被拒绝处理。 404 Not Found服务器已经找到任何匹配Request-URI的资源。 405 Menthod Not AllowedRequest-Line 请求的方法不被允许通过指定的URI。 406 Not Acceptable客户端浏览器不接受所请求页面的 MIME 类型。 407 Proxy Authentication Required要求进行代理身份验证。 408 Reqeust Timeout客服端没有提交任何请求在服务器等待处理时间内。 409 Conflict410 Gone411 Length Required服务器拒绝接受请求在没有定义Content-Length字段的情况下。 412 Precondition Failed前提条件失败。 413 Request Entity Too Large服务器拒绝处理请求因为请求数据超过服务器能够处理的范围。服务器可能关闭当前连接来阻止客服端继续请求。 414 Request-URI Too Long服务器拒绝服务当前请求因为URI的长度超过了服务器的解析范围。 415 Unsupported Media Type服务器拒绝服务当前请求因为请求数据格式并不被请求的资源支持。 416 Request Range Not Satisfialbe所请求的范围无法满足。 417 Expectation Failed执行失败。 Server Error500 Internal Server Error服务器遭遇异常阻止了当前请求的执行 501 Not Implemented服务器没有相应的执行动作来完成当前请求。 502 Bad GatewayWeb 服务器用作网关或代理服务器时收到了无效响应。 503 Service Unavailable因为临时文件超载导致服务器不能处理当前请求。 504 Gateway Timeout网关访问超时。 505 Http Version Not SupportedHTTP 版本不受支持。 &quot;100&quot; : Continue &quot;101&quot; : witching Protocols &quot;200&quot; : OK &quot;201&quot; : Created &quot;202&quot; : Accepted &quot;203&quot; : Non-Authoritative Information &quot;204&quot; : No Content &quot;205&quot; : Reset Content &quot;206&quot; : Partial Content &quot;300&quot; : Multiple Choices &quot;301&quot; : Moved Permanently &quot;302&quot; : Found &quot;303&quot; : See Other &quot;304&quot; : Not Modified &quot;305&quot; : Use Proxy &quot;307&quot; : Temporary Redirect &quot;400&quot; : Bad Request &quot;401&quot; : Unauthorized &quot;402&quot; : Payment Required &quot;403&quot; : Forbidden &quot;404&quot; : Not Found &quot;405&quot; : Method Not Allowed &quot;406&quot; : Not Acceptable &quot;407&quot; : Proxy Authentication Required &quot;408&quot; : Request Time-out &quot;409&quot; : Conflict &quot;410&quot; : Gone &quot;411&quot; : Length Required &quot;412&quot; : Precondition Failed &quot;413&quot; : Request Entity Too Large &quot;414&quot; : Request-URI Too Large &quot;415&quot; : Unsupported Media Type &quot;416&quot; : Requested range not satisfiable &quot;417&quot; : Expectation Failed &quot;500&quot; : Internal Server Error &quot;501&quot; : Not Implemented &quot;502&quot; : Bad Gateway &quot;503&quot; : Service Unavailable &quot;504&quot; : Gateway Time-out &quot;505&quot; : HTTP Version not supported","categories":[{"name":"http","slug":"http","permalink":"https://huangxingx.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://huangxingx.github.io/tags/http/"},{"name":"web","slug":"web","permalink":"https://huangxingx.github.io/tags/web/"}]},{"title":"Python RE","slug":"python-re","date":"2017-11-13T09:21:05.000Z","updated":"2019-06-05T04:37:54.744Z","comments":true,"path":"2017/11/13/python-re/","link":"","permalink":"https://huangxingx.github.io/2017/11/13/python-re/","excerpt":"1.概念：正则表达式（或 RE）是一种小型的、高度专业化的编程语言， （在Python中）它内嵌在Python中，并通过 re 模块实现。使用这个小型语言， 你可以为想要匹配的相应字符串集指定规则；该字符串集可能包含英文语句、email 地址、TeX命令或任何你想搞定的东西。然后你可以问诸如“这个字符串匹配 该模式吗？”或“在这个字符串中是否有部分匹配该模式呢？”。你也可以使用 RE 以各种方式来修改或分割字符串。","text":"1.概念：正则表达式（或 RE）是一种小型的、高度专业化的编程语言， （在Python中）它内嵌在Python中，并通过 re 模块实现。使用这个小型语言， 你可以为想要匹配的相应字符串集指定规则；该字符串集可能包含英文语句、email 地址、TeX命令或任何你想搞定的东西。然后你可以问诸如“这个字符串匹配 该模式吗？”或“在这个字符串中是否有部分匹配该模式呢？”。你也可以使用 RE 以各种方式来修改或分割字符串。 正则表达式语言相对小型和受限（功能有限），因此并非所有字符串处理都能用 正则表达式完成。当然也有些任务可以用正则表达式完成，不过最终表达式会变 得异常复杂。碰到这些情形时，编写 Python 代码进行处理可能反而更好；尽管 Python 代码比一个精巧的正则表达式要慢些，但它更易理解。 2.在正则表达式中， 如下的字符是具有特殊含义的. (所有字符) ^ $ *(0-N次) +(1-N次) ? (0-1次) { } [ ] \\ | ( ) 1).&quot;[&quot; 和 &quot;]&quot;。它们常用来指定一个字符类别，所谓字符类别就是你想匹配的一个字符集 2).其它地方的&quot;^&quot;只会简单匹配 &quot;^&quot;字符本身。例[^5] 将匹配除 &quot;5&quot; 之外的任意字符。 3).反斜杠后面可以加不同的字符以表示不同特殊意义。它也可以用于取消所有的元字符 3.RE 函数用法: findall(rule , target [,flag] ) 在目标字符串中查找符合规则的字符串。 match() 决定 RE 是否在字符串刚开始的位置匹配 search() 扫描字符串，找到这个 RE 匹配的位置 findall() 找到 RE 匹配的所有子串，并把它们作为一个列表返回 finditer() 找到 RE 匹配的所有子串，并把它们作为一个迭代器返回 group() 返回被 RE 匹配的字符串 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置 compile( rule [,flag] )将正则规则编译成一个Pattern对象，以供接下来使用第一个参数 是规则式，第二个参数是规则选项。(使用compile加速) 4 : 含义:预定义转义字符集： “\\d” “\\w” “\\s” 等等，它们是以字符’\\’开头，后面接一个特定 字符的形式,用来指示一个预定义好的含义 ‘^’ 和’$’ 匹配字符串开头和结尾 ‘.’ 匹配所有字符 除\\n以外 ‘\\d’ 匹配数字 ‘\\D’ 匹配非数字 ‘\\w’ 匹配字母和数字 ‘\\W’ 匹配非英文字母和数字 ‘\\s’ 匹配间隔符 ‘\\S’ 匹配非间隔符 ‘\\A’ 匹配字符串开头 ‘\\Z’ 匹配字符串结尾 ‘\\b’ 只用以匹配单词的词首和词尾。单词被定义为一个字母数字序列，因此词尾就 是用空白符或非字母数字符来标示的。(退格) ‘\\B’，它正好同 \\b 相反，只在当前位置不在单词边界时匹配。 5.前向界定与后向界定: ‘(?&lt;=…)’ 前向界定:括号中’…’代表你希望匹配的字符串的前面应该出现的字符串。 ‘(?=…)’后向界定 :括号中的’…’代表你希望匹配的字符串后面应该出现的字符串 ‘(?&lt;!..)’前向非界定 :只有当你希望的字符串前面不是’…’的内容时才匹配 ‘(?!...)’后向非界定 :只有当你希望的字符串后面不跟着’…’内容时才匹配。 6.组的基本知识: ‘(‘’)’ 无命名组 [a-z]+(\\d+)[a-z]+ ‘(?P&lt;name&gt;…)’ 命名组 (?P&lt;g1&gt;[a-z]+)\\d+(?P=g1) ‘(?P=name)’ 调用已匹配的命名组 ‘\\number’ 通过序号调用已匹配的组正则式中的每个组都有一个序号，序号是按组 从左到右，从1开始的数字，你可以通过下面的形式来调用已匹配的组 ( r&quot;(\\d+)([a-z]+)(\\d+)(\\2)(\\1)&quot; )","categories":[{"name":"python","slug":"python","permalink":"https://huangxingx.github.io/categories/python/"}],"tags":[{"name":"re","slug":"re","permalink":"https://huangxingx.github.io/tags/re/"},{"name":"python","slug":"python","permalink":"https://huangxingx.github.io/tags/python/"}]},{"title":"Rabbitmq的web管理界面","slug":"rabbitmq-manager","date":"2017-11-13T09:21:05.000Z","updated":"2019-06-05T04:39:34.536Z","comments":true,"path":"2017/11/13/rabbitmq-manager/","link":"","permalink":"https://huangxingx.github.io/2017/11/13/rabbitmq-manager/","excerpt":"rabbitmq的web管理界面无法使用guest用户登录安装最新版本的rabbitmq(3.3.1)，并启用management plugin后，使用默认的账号guest登陆管理控制台，却提示登陆失败。 翻看官方的release文档后，得知由于账号guest具有所有的操作权限，并且又是默认账号，出于安全因素的考虑，guest用户只能通过localhost登陆使用，并建议修改guest用户的密码以及新建其他账号管理使用rabbitmq(该功能是在3.3.0版本引入的)。 虽然可以以比较猥琐的方式：将ebin目录下rabbit.app中loopback_users里的&lt;&lt;”guest”&gt;&gt;删除， 并重启rabbitmq，可通过任意IP使用guest账号登陆管理控制台，但始终是违背了设计者的初衷，再加上以前对这一块了解也不多，因此有必要总结一下。","text":"rabbitmq的web管理界面无法使用guest用户登录安装最新版本的rabbitmq(3.3.1)，并启用management plugin后，使用默认的账号guest登陆管理控制台，却提示登陆失败。 翻看官方的release文档后，得知由于账号guest具有所有的操作权限，并且又是默认账号，出于安全因素的考虑，guest用户只能通过localhost登陆使用，并建议修改guest用户的密码以及新建其他账号管理使用rabbitmq(该功能是在3.3.0版本引入的)。 虽然可以以比较猥琐的方式：将ebin目录下rabbit.app中loopback_users里的&lt;&lt;”guest”&gt;&gt;删除， 并重启rabbitmq，可通过任意IP使用guest账号登陆管理控制台，但始终是违背了设计者的初衷，再加上以前对这一块了解也不多，因此有必要总结一下。 用户管理 用户管理包括增加用户，删除用户，查看用户列表，修改用户密码。 相应的命令 (1) 新增一个用户 rabbitmqctl add_user Username Password (2) 删除一个用户 rabbitmqctl delete_user Username (3) 修改用户的密码 rabbitmqctl change_password Username Newpassword (4) 查看当前用户列表 rabbitmqctl list_users 用户角色 按照个人理解，用户角色可分为五类，超级管理员, 监控者, 策略制定者, 普通管理者以及其他。 (1) 超级管理员(administrator) 可登陆管理控制台(启用management plugin的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。 (2) 监控者(monitoring) 可登陆管理控制台(启用management plugin的情况下)，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等) (3) 策略制定者(policymaker) 可登陆管理控制台(启用management plugin的情况下), 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。 与administrator的对比，administrator能看到这些内容 (4) 普通管理者(management) 仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对策略进行管理。 (5) 其他 无法登陆管理控制台，通常就是普通的生产者和消费者。 了解了这些后，就可以根据需要给不同的用户设置不同的角色，以便按需管理。 设置用户角色的命令为： rabbitmqctl set_user_tags User Tag User为用户名， Tag为角色名(对应于上面的administrator，monitoring，policymaker，management，或其他自定义名称)。 也可以给同一用户设置多个角色，例如 rabbitmqctl set_user_tags hncscwc monitoring policymaker 用户权限 用户权限指的是用户对exchange，queue的操作权限，包括配置权限，读写权限。配置权限会影响到exchange，queue的声明和删除。读写权限影响到从queue里取消息，向exchange发送消息以及queue和exchange的绑定(bind)操作。 例如： 将queue绑定到某exchange上，需要具有queue的可写权限，以及exchange的可读权限；向exchange发送消息需要具有exchange的可写权限；从queue里取数据需要具有queue的可读权限。详细请参考官方文档中”How permissions work”部分。 相关命令为： (1) 设置用户权限 rabbitmqctl set_permissions -p VHostPath User ConfP WriteP ReadP (2) 查看(指定hostpath)所有用户的权限信息 rabbitmqctl list_permissions [-p VHostPath] (3) 查看指定用户的权限信息 rabbitmqctl list_user_permissions User (4) 清除用户的权限信息 rabbitmqctl clear_permissions [-p VHostPath] User","categories":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://huangxingx.github.io/categories/rabbitmq/"}],"tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://huangxingx.github.io/tags/rabbitmq/"},{"name":"amqp","slug":"amqp","permalink":"https://huangxingx.github.io/tags/amqp/"},{"name":"queue","slug":"queue","permalink":"https://huangxingx.github.io/tags/queue/"}]}]}